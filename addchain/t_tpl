// Function generated by {{ .Meta.Name }}. DO NOT EDIT.
// Computes exponent
#[inline(always)]
fn addchain_exp_by_neg_t(x: Fq12, field_nz: NonZero<u256>) -> Fq12 {
	// Inversion computation is derived from the addition chain:
	//
	{{- range lines (format .Script) }}
	//	{{ . }}
	{{- end }}
	//
	// Operations: {{ .Ops.Doubles }} squares {{ .Ops.Adds }} multiplies
	//
	// Generated by {{ .Meta.Module }} {{ .Meta.ReleaseTag }}.

	{{ range $i := .Program.Instructions }}
	{{- with add $i.Op -}}
	let {{ $i.Output }} = {{ .X }} * {{ .Y }}; // {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
	{{ end -}}
	{{- with double $i.Op -}}
	let {{ $i.Output }} = {{ .X }}.cyclotomic_sqr(field_nz); // {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
	{{ end -}}
	{{- with shift $i.Op -}}
	let {{ $i.Output }} = {{ .X }}.cyclotomic_sqr{{ .S }}(field_nz); // {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
	{{ end -}}
	{{- end }}
	z.conjugate()
}
